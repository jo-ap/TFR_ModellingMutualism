using Oscar
using TikhonovFenichelReductions

# dynamic variables and parameters
x = ["H","S","C"]
p = ["β₂","β₃","δ₁","δ₂","δ₃","μ₁","μ₂", "η", "k₁", "k₂", "k₃"]

# index of parameters that are used for the slow-fast separations (others are fixed)
idx_slow_fast = Bool[1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]

# Define ODE system f
# here we substitute kᵢ := 1/Kᵢ
function f(x, p)
  H, S, C = x
  β₂, β₃, δ₁, δ₂, δ₃, μ₁, μ₂, η, k₁, k₂, k₃ = p
  return [
    -δ₁*H - η*S*H + μ₁*C*(1-H*k₁),
    β₂*S*(1-S*k₂) - δ₂*S - η*S*H  + μ₂*C*(1-S*k₂),
    β₃*C*(1-C*k₃) - δ₃*C + η*S*H
  ]
end

# Dimension of reduced system
s = 2

# find slow-fast separations of rates that are TFPVs
problem = ReductionProblem(f, x, p, s; idx_slow_fast=idx_slow_fast)

@time tfpvs, varieties = tfpvs_and_varieties(problem);

# make variables available in Main namespace
H, S, C = system_components(problem)
β₂, β₃, δ₁, δ₂, δ₃, μ₁, μ₂, η, k₁, k₂, k₃ = system_parameters(problem)

# compute all reductions 
all_varieties = unique_varieties(problem, varieties)

M_auto = [get_explicit_manifold(problem, V) for V in all_varieties]
@assert all([m[2] for m in M_auto])
manifolds = [m[1] for m in M_auto];
manifolds[7] = [H//QQ(1), S//QQ(1), δ₁*H//(μ₁*(1 - k₁*H))]

reductions, idx_M = compute_all_reductions(problem, tfpvs, varieties, manifolds; print=true);

## General TFPVs

# All TFPVs are contained in the affine variety of G
@time G = tfpvs_groebner(problem)

# construct ℝ[π] and a ring homomorphism
R = parent(β₂)
S, v = polynomial_ring(QQ, "_" .* p)
h = hom(S, R, system_parameters(problem))

# the ideal generated by G in the ring S
I = preimage(h, ideal(G));

# compute the saturation I:⟨π₁⋯πₘ⟩^∞
I_sat = saturation(I, ideal(prod(v)))

# check if I_sat = ℝ[π] = ⟨1⟩
is_one(I_sat)
# ⇒ I does not contain monomials

# There are some critical parameters, that are special cases of slow-fast
# separations:
p̃ = R.([0, β₃, 0, 0, δ₃, μ₁, μ₁, 0])

# check if all g∈G vanish for π = p̃
all([evaluate(g, problem.p_sf, p̃) for g in G] .== 0)
